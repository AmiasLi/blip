{"0": {
    "doc": "API",
    "title": "API",
    "content": " ",
    "url": "/blip/v1.0/api",
    "relUrl": "/v1.0/api"
  },"1": {
    "doc": "AWS",
    "title": "AWS",
    "content": "Blip has built-in supprot for Amazon RDS for MySQL and Amazon Aurora. It supports fetching the MySQL password from AWS Secrets Manager and using IAM authentication tokens. ",
    "url": "/blip/v1.0/cloud/aws.html",
    "relUrl": "/v1.0/cloud/aws.html"
  },"2": {
    "doc": "Blip",
    "title": "Blip",
    "content": "Blip configuration is specified in a single YAML file. There are 3 ways to specify the Blip config file. By default, Blip uses blip.yaml in the current working directory: . $ blip . You can specify a config file with the --config command-line option: . $ blip --config FILE . Or, you can specify a config file with the BLIP_CONFIG environment variable: . $ export BLIP_CONFIG=FILE $ blip . The command-line option takes precedent over the environment variable. In the following example, Blip uses only FILE_2: . $ export BLIP_CONFIG=FILE_1 $ blip --config FILE_2 . ",
    "url": "/blip/v1.0/config/blip.html",
    "relUrl": "/v1.0/config/blip.html"
  },"3": {
    "doc": "Cloud",
    "title": "Cloud",
    "content": " ",
    "url": "/blip/v1.0/cloud",
    "relUrl": "/v1.0/cloud"
  },"4": {
    "doc": "Collectors",
    "title": "Metric Collectors",
    "content": "Syntax… . ",
    "url": "/blip/v1.0/metrics/collectors.html#metric-collectors",
    "relUrl": "/v1.0/metrics/collectors.html#metric-collectors"
  },"5": {
    "doc": "Collectors",
    "title": "Collectors",
    "content": " ",
    "url": "/blip/v1.0/metrics/collectors.html",
    "relUrl": "/v1.0/metrics/collectors.html"
  },"6": {
    "doc": "Blip",
    "title": "Blip",
    "content": "In the simplest setup, a single Blip instance monitors (collect metrics from) a single MySQL instance: . But a single instnace of Blip—a single running blip binary—can monitor any number of MySQL instances: . In Blip lingo (and source code), a monitor collects metrics from a single instance of MySQL, as shown above. In short, “a monitor monitors MySQL.” . Monitors are the central concept in Blip, so let’s zoom in on one monitor to see what makes it ticks: . A monitor has more parts than shown above, but three parts are most important: . Sinks Sinks send metrics to some graphing system. A monitor can send metrics to more than one sink. Blip has built-in sinks for SignalFx and Chronosphere, and it’s easy to write your own sink, which means Blip can send metrics anywhere. Plan A plan determines which metrics to collect. Blip has a default plan that collects more than 60 of the most important MySQL metrics. Plans can be customized. Engine The engine is the core part of a monitor that collects metrics from MySQL (according to the plan). There are many more parts to a monitor, but sinks and plans are the two you are most likely to customize—more on this later. You can’t customize the engine, but you can customize the plan that determines which metrics the engine collects. Let’s zoom in on the engine: . Inside the engine, another part called a metrics collector (or collector for short) collects metrics for one domain: a logical group of MySQL metrics. Above, the engine has four collectors that correspond to four domains: . | Domain | Logical Group | . | status.global | SHOW GLOBAL STATUS | . | var.global | SHOW GLOBAL VARIABLES | . | repl | SHOW REPLICA STATUS, … | . | aws | CloudWatch Metrics | . First, you might notice that a collector is not required required to collect metrics from MySQL. An AWS collector, for example, collects related MySQL metrics from Amazon CloudWatch. But most collectors collect metrics from various outputs of MySQL. Second, why a new abstraction—why “domains”? Because MySQL metrics are unorganized, and some metrics can be obtained from multiple outpus. For example, you can obtain the global system variable max_connections from three different outputs (or commands): . | SHOW GLOBAL VARIABLES LIKE 'max_connections'; | SELECT @@GLOBAL.max_connections; | SELECT * FROM global_variables WHERE variable_name='max_connections'; | . That’s a trivial exmaple. Metric domains become important—practically necessary—when you account for the MySQL Performance Schema (and sometimes the MySQL sys Schema), various command and output changes from MySQL 5.6 to 5.7 to 8.0, subtle differences between distributions (Oracle vs. Percona vs. MariaDB), and cloud providers (like Amazon RDS). Metric domains simplify how metrics are collected. As a user, you shouldn’t care how metrics are collected; you should only care which metrics are collected. Domains and plans make that possible… . A level plan (or plan for short) configures which metrics to collect—by domain. Here’s a snippet of a plan that collects two metrics every 5 seconds: . key-perf-indicators: freq: 5s collect: status.global: metrics: - Queries - Threads_running . First of all, don’t worry: Blip has a built-in plan that collects every common and important MySQL metric, including meta-metrics like database and table sizes. You never have to specify a plan, but chances are that you’ll eventually write your own custom plans, espcially when you learn what other Blip features plans make possible. In the plan snippet above (which is YAML syntax), there is a single level called key-perf-indicators collected every 5 seconds (more on levels in a moment). At this level, Blip collects everything configured under collect:, which is just two metrics in the status.global domain: Queries and Threads_running. Real plans a much larger, listing tens (or hunrdeds) of metrics from various domains. Now the quesiton burning in your mind: what are “levels”? A level is a group of metrics collected at a unique frequency. key-perf-indicators metrics are collected every 5 seconds: 5s, 10s, 15s, and so forth. That’s not very fancy! Every metrics collector collects metrics at some frequency. But consider this: . key-perf-indicators: freq: 5s collect: status.global: metrics: - Queries - Threads_running database-sizes: freq: 60s collect: size.data: options: exclude: test_db,dba_stuff metrics: # Automatic . Now the plan has two levels: the original key-perf-indicators plus database-sizes every 60 seconds. (The domain size.data “collects” [calculatues] data size metrics for databases and tables.) Blip combines levels automatically: at 55 seconds, Blip collects only key-perf-indicators metrics; but at 60 seconds, it collects key-perf-indicators metrics and database-sizes metrics. In technical terms, it collects every level where freq % T == 0, where T is the number of seconds elapsed. Now that’s fancy: with level plans, Blip collects different metrics at different frequencies. Levels aren’t just fancy, they’re more efficient and (potentially) less expensive. For example, calculating table sizes when there are thousands of tables can be relatively slow. Consequently, it’s neither wise nor necessary to collect them every few seconds like regular metrics. By relegating table size collection to a slower frequency, regular metrics collection remains fast and efficient. And if you pay for a hosted metrics graphhing solution, then table size metrics every few seconds is a waste of money (because table sizes don’t usually change that fast). Speaking of paying for a hosted metrics graphhing solution, you need to send the metrics somewhere, and anywhere is possible with pluggable metric sinks (or sinks for short). Blip has built-in sinks for SignalFx and Chronosphere, but the sink is an interface, which means its trivial to write a new sink for wherever you send your metrics. Even better: domains make it possible to programmatically transform and rename metrics from Blip to any data format or protocol because Blip metrics have a consistent naming schema: lowercase domain.metric For example, status.global.threads_running. Your sink might strip the domain prefix, or rename it. It could also add labels, dimensions, and so forth—there are no limits. After collecting metrics specified by the plan, Blip passes them (in a simple data structure) to each sink, which are free to do anything (or nothing) with the metrics. Keep learning: Sinks ↓ . ",
    "url": "/blip/v1.0/intro/concepts.html",
    "relUrl": "/v1.0/intro/concepts.html"
  },"7": {
    "doc": "Config File",
    "title": "Config File",
    "content": " ",
    "url": "/blip/v1.0/config/config-file.html",
    "relUrl": "/v1.0/config/config-file.html"
  },"8": {
    "doc": "Config File",
    "title": "Blip Server",
    "content": "api . API config . api: bind: 127.1:7090 disable: false http: proxy: &lt;addr&gt; monitor-loader: freq: 60s files: [one.yaml, two.yaml] stop-loss: 50% aws: regions: [\"auto\",\"us-east-1\"] local: disable-auto: true disable-auto-root: true strict: true . ",
    "url": "/blip/v1.0/config/config-file.html#blip-server",
    "relUrl": "/v1.0/config/config-file.html#blip-server"
  },"9": {
    "doc": "Config File",
    "title": "Defaults for Monitors",
    "content": "Defaults that apply to monitors . aws-rds: iam-auth-token: true password-secret: \"arn::::\" region: \"us-east-1\" disable-auto-region: false disable-auto-tls: false exporter: mode: dual|legacy flags: web.listen-address: :9001 heartbeat: freq: 1s table: blip.heartbeat create-table: try mysql: mycnf: my.cnf username: blip password: blip password-file: \"\" timeout-connect: 5s plans: files: - foo.yaml - bar.yaml table: blip.plans monitor: &lt;monitor&gt; adjust: offline: after: 1s plan: \"\" # collect nothing standby: after: 1s plan: \"\" # collect nothing read-only: after: 1s plan: ro-plan active: after: 1s plan: active-plan sinks: signalfx: auth-token: \"\" auth-token-file: \"\" send-timeout: 2s log: # No options tags: env: ${ENVIRONMENT:-dev} dc: ${DATACENTER:-local} hostname: %{monitor.hostname} tls: ca: square.ca cert: /app/secrets/$%{monitor.hostname}.crt key: /app/secrets/%{monitor.hostname}.key . ",
    "url": "/blip/v1.0/config/config-file.html#defaults-for-monitors",
    "relUrl": "/v1.0/config/config-file.html#defaults-for-monitors"
  },"10": {
    "doc": "Config File",
    "title": "Monitors",
    "content": "MySQL instances to monitor . monitors: - id: host1 hostname: host1.local socket: /tmp/mysql.sock # mysql: mycnf: my.cnf username: metrics password: foo password-file: /dev/shm/mypasswd timeout-connect: 5s aws-rds: password-secret: \"arn::::\" iam-auth-token: true exporter: bind: 127.0.0.1:9001 legacy: false heartbeat: freq: 1s table: blip.heartbeat create-table: try ha: # Reserved plans: table: \"blip.plans\" #monitor: &lt;monitor&gt; adjust: readonly: after: 2s plan: ro.yaml active: after: 1s plan: rw.yaml sinks: signalfx: auth-token: \"\" auth-token-file: \"\" send-timeout: 2s log: # No options chronosphere: url: http://127.0.0.1:3030/openmetrics/write tags: env: staging monitor-id: %{monitor.id} tls: ca: my-ca cert: ${SECRETS}/%{monitor.hostname}.cert key: ${SECRETS}/%{monitor.hostname}.key meta: source: host2.local canary: no . ",
    "url": "/blip/v1.0/config/config-file.html#monitors",
    "relUrl": "/v1.0/config/config-file.html#monitors"
  },"11": {
    "doc": "Configure",
    "title": "Configure",
    "content": " ",
    "url": "/blip/v1.0/config",
    "relUrl": "/v1.0/config"
  },"12": {
    "doc": "Domains",
    "title": "Metric Domains",
    "content": ". | repl | status.global | var.global | . ",
    "url": "/blip/v1.0/metrics/domains.html#metric-domains",
    "relUrl": "/v1.0/metrics/domains.html#metric-domains"
  },"13": {
    "doc": "Domains",
    "title": "repl",
    "content": "Replication metrics . ",
    "url": "/blip/v1.0/metrics/domains.html#repl",
    "relUrl": "/v1.0/metrics/domains.html#repl"
  },"14": {
    "doc": "Domains",
    "title": "status.global",
    "content": "Global status vars . ",
    "url": "/blip/v1.0/metrics/domains.html#statusglobal",
    "relUrl": "/v1.0/metrics/domains.html#statusglobal"
  },"15": {
    "doc": "Domains",
    "title": "var.global",
    "content": "Global sysvars . ",
    "url": "/blip/v1.0/metrics/domains.html#varglobal",
    "relUrl": "/v1.0/metrics/domains.html#varglobal"
  },"16": {
    "doc": "Domains",
    "title": "Domains",
    "content": " ",
    "url": "/blip/v1.0/metrics/domains.html",
    "relUrl": "/v1.0/metrics/domains.html"
  },"17": {
    "doc": "Endpoints",
    "title": "Endpoints",
    "content": ". | Requests . | Create and start a new request | Get a request | Stop a request | Get all job logs for a request | Get logs for a specific job in a request | Get status of all running jobs and requests | Find requests that match certain conditions | Get list of all available requests | . | . ",
    "url": "/blip/v1.0/api/endpoints.html",
    "relUrl": "/v1.0/api/endpoints.html"
  },"18": {
    "doc": "Endpoints",
    "title": "Requests",
    "content": "All things related to Spin Cycle requests. Create and start a new request . POST . /api/v1/requests . Request Parameters . | Parameter | Type | Description | . | type | string | The type of request to create | . | args | object | The arguments for the request | . Sample Request Body . { \"type\": \"test\", \"args\": { \"sleepTime\": \"1000\" } } . Sample Response . { \"id\": \"bafebl1ddiob71ka5bag\", \"type\": \"test\", \"state\": 1 \"user\": \"kristen\", \"args\": { \"sleepTime\": \"1000\" }, \"createdAt\": \"2019-03-15T16:49:59Z\", \"startedAt\": \"2019-03-15T16:49:59Z\", \"finishedAt\": \"2019-03-15T16:55:42Z\", \"totalJobs\": 2, \"finishedJobs\": 0 } . Response Status Codes . 201: Successful operation. 400: Invalid request. Either the request type does not exist, or the args are invalid. 401: Unauthorized operation. 503: The Request Manager (RM) API server is in the process of shutting down. Get a request . GET . /api/v1/requests/${requestId} . Sample Response . { \"id\": \"bihqongkp0sg00cq9vo0\", \"type\": \"test\", \"state\": 3, \"user\": \"kristen\", \"args\": [ { \"Pos\": 0, \"Name\": \"sleepTime\", \"Desc\": \"How long to sleep (milliseconds) during the request. Useful to verify how RM and JR respond before request has finished.\", \"Type\": \"optional\", \"Given\": true, \"Default\": \"1000\", \"Value\": \"1000\" } ], \"createdAt\": \"2019-04-02T18:39:26Z\", \"startedAt\": \"2019-04-02T18:39:26Z\", \"finishedAt\": \"2019-04-02T18:39:27Z\", \"JobChain\": { \"requestId\": \"bihqongkp0sg00cq9vo0\", \"jobs\": { \"3RNT\": { \"id\": \"3RNT\", \"name\": \"wait\", \"type\": \"sleep\", \"bytes\": \"eyJkdXJhdGlvbiI6MTAwMDAwMDAwMH0=\", \"state\": 1, \"args\": { \"duration\": \"1000\" }, \"retry\": 0, \"sequenceId\": \"FDbP\", \"sequenceRetry\": 0 }, \"eSTn\": { \"id\": \"eSTn\", \"name\": \"wait\", \"type\": \"sleep\", \"bytes\": \"eyJkdXJhdGlvbiI6MTAwMDAwMDAwMH0=\", \"state\": 1, \"args\": { \"duration\": \"1000\" }, \"retry\": 0, \"sequenceId\": \"cDNR\", \"sequenceRetry\": 0 } }, \"adjacencyList\": { \"3RNT\": [ \"eSTn\" ] } }, \"totalJobs\": 2, \"finishedJobs\": 2 } . Response Status Codes . 200: Successful operation. 401: Unauthorized operation. 404: Request not found. Stop a request . PUT . /api/v1/requests/${requestId}/stop . Response Status Codes . 200: Successful operation. 401: Unauthorized operation. 404: Request not found. Get all job logs for a request . GET . /api/v1/requests/${requestId}/log . Sample Response . [ { \"requestId\": \"bihqongkp0sg00cq9vo0\", \"jobId\": \"3RNT\", \"try\": 1, \"name\": \"wait\", \"type\": \"sleep\", \"startedAt\": 1554230366094196500, \"finishedAt\": 1554230367094791700, \"state\": 3, \"exit\": 0, \"error\": \"\", \"stdout\": \"\", \"stderr\": \"\" }, { \"requestId\": \"bihqongkp0sg00cq9vo0\", \"jobId\": \"eSTn\", \"try\": 1, \"name\": \"wait\", \"type\": \"sleep\", \"startedAt\": 1554230366095376600, \"finishedAt\": 1554230367096359700, \"state\": 3, \"exit\": 0, \"error\": \"\", \"stdout\": \"\", \"stderr\": \"\" } ] . Response Status Codes . 200: Successful operation. 401: Unauthorized operation. 404: Request not found. Get logs for a specific job in a request . GET . /api/v1/requests/${requestId}/log/${jobId} . Sample Response . { \"requestId\": \"bihqongkp0sg00cq9vo0\", \"jobId\": \"3RNT\", \"try\": 1, \"name\": \"wait\", \"type\": \"sleep\", \"startedAt\": 1554230366094196500, \"finishedAt\": 1554230367094791700, \"state\": 3, \"exit\": 0, \"error\": \"\", \"stdout\": \"\", \"stderr\": \"\" } . Response Status Codes . 200: Successful operation. 401: Unauthorized operation. 404: Request or job not found. Get status of all running jobs and requests . GET . /api/v1/status/running . Sample Response . { \"jobs\": [ { \"requestId\": \"bihr0sgkp0sg00cq9vog\", \"jobId\": \"96i7\", \"type\": \"sleep\", \"name\": \"wait\", \"startedAt\": 1554231410126312200, \"state\": 2, \"status\": \"sleeping\", \"try\": 1 }, { \"requestId\": \"bihr0tgkp0sg00cq9vp0\", \"jobId\": \"4avk\", \"type\": \"sleep\", \"name\": \"wait\", \"startedAt\": 1554231414572741000, \"state\": 2, \"status\": \"sleeping\", \"try\": 1 } ], \"requests\": { \"bihr0sgkp0sg00cq9vog\": { \"id\": \"bihr0sgkp0sg00cq9vog\", \"type\": \"test\", \"state\": 2, \"user\": \"\", \"createdAt\": \"2019-04-02T18:56:50Z\", \"startedAt\": \"2019-04-02T18:56:50Z\", \"finishedAt\": null, \"totalJobs\": 2, \"finishedJobs\": 0 }, \"bihr0tgkp0sg00cq9vp0\": { \"id\": \"bihr0tgkp0sg00cq9vp0\", \"type\": \"test\", \"state\": 2, \"user\": \"\", \"createdAt\": \"2019-04-02T18:56:55Z\", \"startedAt\": \"2019-04-02T18:56:55Z\", \"finishedAt\": null, \"totalJobs\": 2, \"finishedJobs\": 0 } } } . Response Status Codes . 200: Successful operation. 401: Unauthorized operation. Find requests that match certain conditions . GET . /api/v1/requests . Requests are returned in descending order by create time (i.e. most recently created first). Optional Query Parameters . | Parameter | Description | Notes | . | type | The type of request |   | . | user | The user who created the request |   | . | state | The state of the request | See proto.go — the string name of the state, not the byte. Specify this parameter multiple times to search for multiple states. | . | since | Return only requests which were running after this time | Format: 2006-01-02T15:04:05.999999Z07:00 | . | until | Return only requests which were running before this time | Format: 2006-01-02T15:04:05.999999Z07:00 | . | limit | Maximum number of requests to return |   | . | offset | Skip this number of requests | Use with limit for pagination of results. | . Sample Response . [ { \"id\": \"bihr0sgkp0sg00cq9vog\", \"type\": \"test\", \"state\": 2, \"user\": \"Bob\", \"createdAt\": \"2019-04-02T18:56:50Z\", \"startedAt\": \"2019-04-02T18:56:50Z\", \"finishedAt\": null, \"totalJobs\": 2, \"finishedJobs\": 0 }, { \"id\": \"bihr0tgkp0sg00cq9vp0\", \"type\": \"test\", \"state\": 3, \"user\": \"Alice\", \"createdAt\": \"2019-04-02T18:56:55Z\", \"startedAt\": \"2019-04-02T18:56:55Z\", \"finishedAt\": \"2019-04-02T18:57:55Z\", \"totalJobs\": 2, \"finishedJobs\": 2 } ] . Response Status Codes . 200: Successful operation. 400: Invalid parameters. 401: Unauthorized operation. Get list of all available requests . GET . /api/v1/request-list . Sample Response . [ { \"Name\": \"test\", \"Args\": [ { \"Pos\": 0, \"Name\": \"sleepTime\", \"Desc\": \"How long to sleep (milliseconds) during the request. Useful to verify how RM and JR respond before request has finished.\", \"Type\": \"optional\", \"Given\": false, \"Default\": \"1000\", \"Value\": null } ] } ] . Response Status Codes . 200: Successful operation. 401: Unauthorized operation. ",
    "url": "/blip/v1.0/api/endpoints.html#requests",
    "relUrl": "/v1.0/api/endpoints.html#requests"
  },"19": {
    "doc": "Heartbeat",
    "title": "Heartbeat",
    "content": "Blip has a built-in heartbeat feature for measuring replication lag. ",
    "url": "/blip/v1.0/heartbeat",
    "relUrl": "/v1.0/heartbeat"
  },"20": {
    "doc": "Home",
    "title": "GitHub Repo",
    "content": "https://github.com/cashapp/blip . Official releases are tagged with version. Only the latest version is stable and supported. ",
    "url": "/blip/#github-repo",
    "relUrl": "/#github-repo"
  },"21": {
    "doc": "Home",
    "title": "Support",
    "content": "For bugs and general issues, please create a new GitHub issue. If submitting code changes, please also see the contributing guide. ",
    "url": "/blip/#support",
    "relUrl": "/#support"
  },"22": {
    "doc": "Home",
    "title": "Release Notes",
    "content": ". | Release Notes | . ",
    "url": "/blip/#release-notes",
    "relUrl": "/#release-notes"
  },"23": {
    "doc": "Home",
    "title": "Home",
    "content": ". Blip is the most advanced MySQL metrics collector ever built. | Connects to MySQL anywhere—local, remote, bare metal, cloud | Monitors one or many MySQL instances per blip instance | Configurable metrics collection—metrics are not hard-coded | Different metric collection frequencies—collect metrics at different intervals | Built-in support for Amazon RDS include Secrets Manager and IAM authentication | Send metrics to any back end—built-in support for SignalFx and Chronosphere | Plugins and factories to integrate with any environment | . Start by reading the Introduction. Then read the Quick Start to give Blip a try. ",
    "url": "/blip/",
    "relUrl": "/"
  },"24": {
    "doc": "Release Notes",
    "title": "Release Notes",
    "content": " ",
    "url": "/blip/release-notes",
    "relUrl": "/release-notes"
  },"25": {
    "doc": "Release Notes",
    "title": "v1.0",
    "content": "v1.0.0 (not released yet) . | First GA, production-ready release. | . ",
    "url": "/blip/release-notes#v10",
    "relUrl": "/release-notes#v10"
  },"26": {
    "doc": "Integrate",
    "title": "Integrate",
    "content": "Blip was designed from the ground up to integrate with your MySQL environment. To accomplish that, Blip has two mains points of integration: . Plugins Plugins are function callbacks that let you override specific functionality of Blip. Every plugin is optional: if specified, it overrides the built-in functionality. Factories Factories are interfaces that let you override certain object creation of Blip. Every factory is optional: if specified, it overrides the built-in factory. ",
    "url": "/blip/v1.0/integrate",
    "relUrl": "/v1.0/integrate"
  },"27": {
    "doc": "Introduction",
    "title": "Introduction to Blip",
    "content": " ",
    "url": "/blip/v1.0/intro#introduction-to-blip",
    "relUrl": "/v1.0/intro#introduction-to-blip"
  },"28": {
    "doc": "Introduction",
    "title": "Introduction",
    "content": " ",
    "url": "/blip/v1.0/intro",
    "relUrl": "/v1.0/intro"
  },"29": {
    "doc": "Laptop",
    "title": "Laptop",
    "content": "Presuming a standard MySQL insstance runs on your laptop, first create a blip user: . CREATE USER IF NOT EXISTS 'blip' IDENTIFIED BY ''; -- no password GRANT SELECT ON `performance_schema`.* TO 'blip'@'%'; -- no privlieges . Then run blip (after compiling it in bin/blip/, of course): . $ blip . By default, Blip automatically finds local MySQL instances, and tries a few default username-password combinations. If successful, it will dump metrics to STDOUT. If not successful, run with --debug. ",
    "url": "/blip/v1.0/quick-start/laptop.html",
    "relUrl": "/v1.0/quick-start/laptop.html"
  },"30": {
    "doc": "Metrics",
    "title": "Metrics",
    "content": " ",
    "url": "/blip/v1.0/metrics",
    "relUrl": "/v1.0/metrics"
  },"31": {
    "doc": "Monitors",
    "title": "Monitors",
    "content": "Every MySQL instance that Blip monitors is called a moniotr. For simplicity, the terms monitor and MySQL instance are synonymous because a monitor requires and represents only one MySQL instance. But there is more to a monitor than its MySQL instance. NOTE: Monitor and MySQL instance are synonymous in Blip. Monitors are usually specififed in the Blip config file, but they can be loaded various ways—more on this later. For now, it’s only necessary to know that monitors are listed in the YAML config file under the aptly named section moniotrs. The most basic Blip monitor is a simple hostname, username, and password: . monitors: - hostname: 127.0.0.1 username: blip password: aStrongRandomPassword . Or, if you want to use a my.cnf file: . monitors: - mycnf: ${HOME}/.my.cnf . A single Blip instances can monitor any number of MySQL instances. Here is a snippet of config that specifies three different MySQL instances: . monitors: - socket: /tmp/mysql.sock username: blip password-file: /dev/shm/metrics-password - hostname: 10.1.1.53 username: metrics password: foo - hostname: db3.us-east-1.amazonaws.com aws-rds: auth-token: true . The first instance is local: Blip connects using socket file /tmp/mysql.sock. The second instance is remote: Blip connects to IP 10.1.1.53. The third instance is an Amazon RDS for MySQL instance, and Blip uses IAM authentication. The point of these contrived examples is: Blip can monitor any MySQL instance anywhere it’s running. (If you have a case where this is not true, please file an issue.) . By default, Blip first attempts to load monitors from its config file (which is blip.yaml in the current working directory, by default). But the config file can specify other ways to load monitors: . monitor-loader: freq: 60s files: [monitors1.yaml, monitors2.yaml] . In short, that config snippet makes Blip load (read) monitor configuration from files monitors1.yaml and monitors2.yaml every 60 seconds. (Blip can dynamically load [add] and unload [remove] monitors while running.) The monitor-load config is optional; by default, Blip loads monitors from the monitors section in its config file. To further ensure that Blip can monitory any MySQL instance, loading monitors is an optional plugin with this callback signature: . LoadMonitors func(Config) ([]ConfigMonitor, error) . Hopefully, bilt-in features cover every use case, but if you have particular requirements (filtering out certain MySQL instances, for example), you can plug in your own code to load monitors. In addition to basic MySQL configuration—how to connect to MySQL: hostname, username, and password, and so forth—monitors have other optional features and configuration, summarized briefly in the following table. | Monitor Confg | Feature | . | aws | Amazon RDS authentication | . | exporter | Prometheus mysqld_exporter emulation | . | ha | High availability (not implemented yet) | . | heartbeat | Heartbeat to measure replication lag | . | meta | User-defined key-value data | . | plans | Monitor-specific plans for metrics collection | . | sinks | Monitors-specific sinks for sending metrics | . | tags | Monitor-specific key-value data passed to sinks | . | tls | TLS configuration | . That’s a lot of information, but the point is a lot simpler: Blip monitors can do almost anything. For the most part, these features support Blip in large, automated environments. If you don’t need a feature, you can forget about it: Blip is simple (and fully automatic) by default. When you need a feature, Blip most likely already supports it. One last helpful tip: . $ blip --print-moniotrs --run=false . The command line above starts (but does not run) Blip so that it loads monitors and prints them, then exists. This can help debug monitor loading and configuration. Keep learning: Plans ↓ . ",
    "url": "/blip/v1.0/intro/monitors.html",
    "relUrl": "/v1.0/intro/monitors.html"
  },"32": {
    "doc": "Plans",
    "title": "Plans",
    "content": "A level plan (or plan for short) configures which metrics to collect. Plans solve three problems: . | Which metrics to collect? | How to collect those metrics? | How often to collect those metrics? | . The first problem arises because there are over 1,000 MySQL metrics but 0 standards for which metrics to collect. Some engineers collect nearly all metrics and use what they need in graphs. Some engineers collect as few metrics as possible due to costs. Some engineers don’t know what to collect, relying on monitor defaults to be useful. Plans help solve the first problem by not hard-coding which metcis to collect. Write a plan to collect only the metrics you need. Blip has a built-in default plan that collects more than 60 of the most important MySQL metrics, which might be all you need. The second problem arises because there are many versions and distributions of MySQL, which makes some metrics a moving target. For example: where do you collect a MySQL replication lag metric? The oldest and perhaps still most common source is Seconds_Behind_Master in the SHOW SLAVE STATUS output. But those two changed to Seconds_Behind_Source and SHOW REPLICA STATUS, respectively. And what if you don’t use those and, instead, use pt-heartbeat or the Blip built-in heartbeat? Or what if you’re running MySQL Group Replication? Or what if you run MySQL in the cloud and the cloud provider emits its own replication lag metric? . Plans help solve the second problem by using metric domains (or domains for short) to name logically-related group of MySQL metrics. Probably the most well known group is SHOW GLOBAL STATUS, to which Blip gives the domain name status.global. A replication lag metric is scoped within the repl domain (short for “replication”), which hides (abstarcts way) the technical details of how it’s collected. When you write a plan that collects replication lag, the plan works everywhere because domains specify which metrics to collect, not necessarily how to collect them. The third problem arises from cost and storage limits: if everything was fast and free, you would collect all metrics every 1 second. But this is (almost) never done because it requires signfiicant storage and processing, which lead to significant costs. Instead, the norm is collecting all metrics every 10, 20, or 30 seconds. But even 10 seconds is too long for a busy database because, for example, at only 5,000 QPS, that resolution averages out the metrics for 50,000 queries. Plans help solve the third problem by allowing you to collect different metrics at different frequencies—which is the “level” in the full term: “level plan”. It helps to remember as: “Higher the level, higher the wait (time between collection).” For example, imagine three levels as shown below. Level 1, the base level, is collected frqeuently (shortest wait time): every 5 seconds. Level 2 is collected less frequently: every 20 seconds. Level 3, the highest level, is collected the most infrequently (longest wait time): every 30 seconds. Blip automatically combines levels when they overlap and collects all metrics at that time. At 20 seconds (since Blip started collecting metrics for this plan), Blip collects metrics for both levels 1 and 2 because 20 mod 5 = 0 and 20 mod 20 = 0, respectively. At 30 seconds, Blip collects metrics for both levels 1 anbd 3 because 30 mod 5 = 0 and 30 mod 20 = 0, respectively. And at 60 seconds, Blip collecgts metrics for all three levels because 60 mod freq = 0. Blip plans can do more, but for this introduction it’s sufficient to know that they allow you to fine-tune metrics collection, which increases the quality of monitoring while reducing costs. Keep going: Quick Start ↓ . ",
    "url": "/blip/v1.0/intro/plans.html",
    "relUrl": "/v1.0/intro/plans.html"
  },"33": {
    "doc": "Plans",
    "title": "Plans",
    "content": " ",
    "url": "/blip/v1.0/plans",
    "relUrl": "/v1.0/plans"
  },"34": {
    "doc": "Prometheus",
    "title": "Prometheus",
    "content": "Blip can emulate Prometheus mysqld_exporter. ",
    "url": "/blip/v1.0/prometheus",
    "relUrl": "/v1.0/prometheus"
  },"35": {
    "doc": "Quick Reference",
    "title": "Quick Reference",
    "content": "Interpolation . $ENV_VAR %{monitor.hostname} . Config File . Following is a full Blip config file (YAML syntax). This is only a reference to show all configuration variables. --- # --------------------------------------------------------------------------- # Blip server # --------------------------------------------------------------------------- api: bind: 127.1:7090 disable: false http: proxy: &lt;addr&gt; monitor-loader: freq: 60s files: [one.yaml, two.yaml] stop-loss: 50% aws: regions: [\"auto\",\"us-east-1\"] local: disable-auto: true disable-auto-root: true strict: true # --------------------------------------------------------------------------- # Defaults for monitors # --------------------------------------------------------------------------- aws-rds: iam-auth-token: true password-secret: \"arn::::\" region: \"us-east-1\" disable-auto-region: false disable-auto-tls: false exporter: mode: dual|legacy flags: web.listen-address: :9001 heartbeat: freq: 1s table: blip.heartbeat create-table: try mysql: mycnf: my.cnf username: blip password: blip password-file: \"\" timeout-connect: 5s plans: files: - foo.yaml - bar.yaml table: blip.plans monitor: &lt;monitor&gt; adjust: offline: after: 1s plan: \"\" # collect nothing standby: after: 1s plan: \"\" # collect nothing read-only: after: 1s plan: ro-plan active: after: 1s plan: active-plan sinks: signalfx: auth-token: \"\" auth-token-file: \"\" send-timeout: 2s log: # No options tags: env: ${ENVIRONMENT:-dev} dc: ${DATACENTER:-local} hostname: %{monitor.hostname} tls: ca: square.ca cert: /app/secrets/$%{monitor.hostname}.crt key: /app/secrets/%{monitor.hostname}.key # --------------------------------------------------------------------------- # MySQL instances to monitor # --------------------------------------------------------------------------- monitors: - id: host1 hostname: host1.local socket: /tmp/mysql.sock # mysql: mycnf: my.cnf username: metrics password: foo password-file: /dev/shm/mypasswd timeout-connect: 5s aws-rds: password-secret: \"arn::::\" iam-auth-token: true exporter: bind: 127.0.0.1:9001 legacy: false heartbeat: freq: 1s table: blip.heartbeat create-table: try ha: # Reserved plans: table: \"blip.plans\" #monitor: &lt;monitor&gt; adjust: readonly: after: 2s plan: ro.yaml active: after: 1s plan: rw.yaml sinks: signalfx: auth-token: \"\" auth-token-file: \"\" send-timeout: 2s log: # No options chronosphere: url: http://127.0.0.1:3030/openmetrics/write tags: env: staging monitor-id: %{monitor.id} tls: ca: my-ca cert: ${SECRETS}/%{monitor.hostname}.cert key: ${SECRETS}/%{monitor.hostname}.key meta: source: host2.local canary: no . ",
    "url": "/blip/v1.0/config/quick-ref.html",
    "relUrl": "/v1.0/config/quick-ref.html"
  },"36": {
    "doc": "Quick Reference",
    "title": "Environment Variables",
    "content": "Most config options have a corresponding environment variable, like SPINCYCLE_RM_CLIENT_URL for rm_client.url. Exceptions are noted. Take a config option, change . to _, upper-case everything, and add SPINCYCLE_ prefix. ",
    "url": "/blip/v1.0/config/quick-ref.html#environment-variables",
    "relUrl": "/v1.0/config/quick-ref.html#environment-variables"
  },"37": {
    "doc": "Quick Reference",
    "title": "Quick Reference",
    "content": "Interpolation . $ENV_VAR %{monitor.hostname} . Plan File . Following is a full Blip config file (YAML syntax). This is only a reference to show all configuration variables. --- level_1: freq: 5s collect: domain1: options: opt_1: value_1 opt_N: value_N metrics: - metric_1 - metric_N level_N: freq: 10s collect: domain_1: options: opt_1: value_1 opt_N: value_N metrics: - metric_1 - metric_N . ",
    "url": "/blip/v1.0/plans/quick-ref.html",
    "relUrl": "/v1.0/plans/quick-ref.html"
  },"38": {
    "doc": "Quick Start",
    "title": "Quick Start",
    "content": " ",
    "url": "/blip/v1.0/quick-start",
    "relUrl": "/v1.0/quick-start"
  },"39": {
    "doc": "Sinks",
    "title": "Metric Sinks",
    "content": "Syntax… . ",
    "url": "/blip/v1.0/metrics/sinks.html#metric-sinks",
    "relUrl": "/v1.0/metrics/sinks.html#metric-sinks"
  },"40": {
    "doc": "Sinks",
    "title": "Sinks",
    "content": " ",
    "url": "/blip/v1.0/metrics/sinks.html",
    "relUrl": "/v1.0/metrics/sinks.html"
  },"41": {
    "doc": "Sinks",
    "title": "Sinks",
    "content": "NOTE: You can skip this part of the introduction if: . | You use SignalFx, or | You use Chronosphere, or | You plan to use Blip to emulate and replace Prometheus `mysqld_exporter` | . Blip has built-in support for these three use cases. Blip ships with built-in and automatic support for almost everything, but the one thing we (the Blip developers) cannot know is where you (the user) will send metrics. Consequently, you might need to develop a Blip metric sink to translate and send Blip metrics to your metrics store or metrics graphing solution. Don’t worry: Bilp was intentially designed to make this easy. This brief introduction shows the high-level process of developing a new Blip metric sink. The following presumes that you’re an experienced Go programmer. All Blip sinks implement this interface: . type Sink interface { Send(context.Context, *Metrics) error Status() string } . Unsurprisingly, Blip calls the Send method to send metrics. The vast majority of work to implement a new sink is this one method. More on this in a moment. Blip calls the Status method to report real-time status of the sink (along with all other parts in the monitor). The reported status can be anything you think is useful to know; for exmaple, the last error sending metrics (if any). Let’s presume, for a moment, that you have implement a new sink. To allow Blip to make (instantiate) that sink, you implement one last interface: . type SinkFactory interface { Make(name, monitorId string, opts, tags map[string]string) (Sink, error) } . When a monitor uses your sink, Blip calls your sink factory to make a new sink for the monitor. Blip passes to your factory: . | Sink name (which is slightly redundant, but nobody is perfect) | Monitor ID (all monitors have a unique ID for status, logging, and so forth”) | Options (from the monitor config) | Tags (from the monitor config) | . Options are sink-specific options; for example, an API token is common for authenticating to hosted metrics soltuions. Tags describe the metrics; some metrics solutions calls these “dimensions”, others call them “labels”—Blip calls them “tags”. Options are tags are set in the monitor config, which you’ll learn more about later. Here’s a mock (incomplete and nonfunctional) implementation of a sink (called “Kim” for an engineer who left us [the Blip developers] to join a metrics solution startup) and sink factory, just to give you an idea: . import ( \"context\" \"github.com/cashapp/blip\" ) type Kim struct { tags map[string]string client Client // sink-specific client } func NewKim(monitorId string, opts, tags map[string]string) *Kim { return &amp;Kim{ tags: tags, client: NewClient(opts[\"addr\"], opts[\"api-token\"]), } } func (k *Kim) Send(cxt context.Context, metrics *blip.Metrics) error { // Metrics are grouped by/keyed on domain name for domain := range metrics { // Loop through metrics in each domain for i := range metrics[domain] { m := metrics[domain][i] // Name: m.Name (string) // Value: m.Value (float64) // Type: m.Type (const byte) // Transform Blip metrics to sink-specific struct/protocol } } // Send sink-specific struct/protocol (km) return k.client.Send(ctx, km) } func (k *Kim) Status() string { return \"I miss where I used to work\" } // -------------------------------------------------------------------------- type KimFactory struct{} func (f KimFactory) Make(name, monitorId string, opts, tags map[string]string) (blip.Sink, error) { k := NewKim(monitorId, opts, tags) return k, nil } . For real sinks, see the built-in Blip sinks: blip/sinks. Once your implementation is done, you register the sink with Blip: . sink.Register(\"kim\", KimFactory{}) . More on this later; for now, the point is that you register your sink with a given name (“kim”), and that name is important because it’s what you specify in a monitor config to make Blip instantiate the sink. Following is a snippet of a monitor config that shows how the “kim” sink is used and configured: . monitors: - id: host1 hostname: host1.local sinks: kim: addr: https://local.domain api-token: ABC123 tags: env: staging region: us-east-1 . On line 5, the “kim” sink is specified, and lines 6 and 7 are its options. Lines 9 and 10 are tags for the monitor, which are also passed to the sink when created. Keep learning: Monitors ↓ . ",
    "url": "/blip/v1.0/intro/sinks.html",
    "relUrl": "/v1.0/intro/sinks.html"
  }
}
